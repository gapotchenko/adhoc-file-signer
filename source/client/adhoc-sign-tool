#!/usr/bin/env bash

set -euo pipefail

# -----------------------------------------------------------------------------

NAME=adhoc-sign-tool
VERSION=0.0.0

help() {
    echo "$NAME  Version $VERSION
Copyright Â© Gapotchenko and Contributors

Processes the specified file(s) using the 'adhoc-file-signer' service.

Usage:
  adhoc-sign-tool sign --server <server-url> -k <api-key> <file...>
                       [--dry] [--verbose]
  adhoc-sign-tool echo --server <server-url> -k <api-key> <file...>
                       [--verbose]
  adhoc-sign-tool ping --server <server-url> -k <api-key> [--verbose]

Commands:
  sign  Sign the specified file(s) using the server.
  echo  Send the specified file(s) to the server and recieve them back
        unmodified. Useful for testing connectivity and data transfer.
  ping  Ping the server using its API. Useful for testing connectivity and
        verifying authorization.

Options:
  --server      The server URL. If omitted, the value of
                GP_ADHOC_FILE_SIGNER_SERVER environment variable is used.
  -k --api-key  The API authorization key. If omitted, the value of
                GP_ADHOC_FILE_SIGNER_API_KEY environment variable is used.
  --verbose     Enable verbose output.
  --dry         Perform a dry run without applying any modifications."
}

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

if [ $# -eq 0 ]; then
    echo "$NAME: missing program arguments
Try '$NAME --help' for more information." >&2
    exit 2
fi

OPT_COMMAND=
OPT_SERVER_URL="${GP_ADHOC_FILE_SIGNER_SERVER-}"
OPT_API_KEY="${GP_ADHOC_FILE_SIGNER_API_KEY-}"
OPT_FILES=""
OPT_DRY=""
OPT_VERBOSE=""

OPT_HAS_STDIN_FILE=0

opt_add_file() {
    if [ "$1" = "-" ]; then
        OPT_HAS_STDIN_FILE=1
    fi

    if [ -z "$OPT_FILES" ]; then
        OPT_FILES=$1
    else
        OPT_FILES="$OPT_FILES
$1"
    fi
}

# Parse options
while [ $# -gt 0 ]; do
    case "$1" in
    --help)
        help
        exit
        ;;
    --server)
        OPT_SERVER_URL="$2"
        shift 2
        ;;
    -k | --api-key)
        OPT_API_KEY="$2"
        shift 2
        ;;
    --dry)
        OPT_DRY=1
        shift
        ;;
    --verbose)
        OPT_VERBOSE=1
        shift
        ;;
    --)
        shift
        break
        ;;
    -)
        opt_add_file "$1"
        shift
        ;;
    -*)
        echo "$NAME: unknown option: $1" >&2
        exit 2
        ;;
    *)
        # Positional arguments
        if [ -z "$OPT_COMMAND" ]; then
            case "$1" in
            echo | ping | sign)
                OPT_COMMAND=$1
                ;;
            *)
                echo "$NAME: unknown command: $1" >&2
                exit 2
                ;;
            esac
        else
            opt_add_file "$1"
        fi
        shift
        ;;
    esac
done

# Validate options

opt_error_missing() {
    echo "$NAME: $1 is not specified." >&2
    exit 2
}

if [ -z "$OPT_COMMAND" ]; then
    opt_error_missing 'command'
fi
if [ -z "$OPT_SERVER_URL" ]; then
    opt_error_missing 'server URL'
fi
if [ -z "$OPT_API_KEY" ]; then
    opt_error_missing 'API key'
fi

if [ -n "$OPT_DRY" ]; then
    case "$OPT_COMMAND" in
    sign) ;;
    *)
        echo "$NAME: '--dry' option can only be used with 'sign' command." >&2
        exit 2
        ;;
    esac
fi

# Complete positional arguments
while [ $# -gt 0 ]; do
    opt_add_file "$1"
    shift
done

# Validate positional options
case "$OPT_COMMAND" in
echo | sign)
    if [ -z "$OPT_FILES" ]; then
        echo "$NAME: missing file argument." >&2
        exit 2
    fi
    ;;
*)
    if [ -n "$OPT_FILES" ]; then
        echo "$NAME: files can only be specified for 'echo' and 'sign' commands." >&2
        exit 2
    fi
    ;;
esac

# Options normalization

opt_normalize_server_url() {
    OPT_SERVER_URL=${OPT_SERVER_URL%/}
}

opt_normalize_server_url

# -----------------------------------------------------------------------------
# Auxilary Functions
# -----------------------------------------------------------------------------

log() {
    if [ $OPT_HAS_STDIN_FILE -eq 1 ]; then
        echo "$@" >&2
    else
        echo "$@"
    fi
}

verbose() {
    echo "LOG:" "$@" >&2
}

get_file_extension() {
    expr "x$1" : '.*\.\([^.]*\)$' | tr '[:upper:]' '[:lower:]' || true
}

on_exit() {
    if [ "$1" -ne 0 ]; then
        echo "$NAME: failed with status $1." >&2
    fi
    # Cleanup
    [ -n "${hdrfile-}" ] && rm -f "$hdrfile" || true
    [ -n "${tmpfile-}" ] && rm -f "$tmpfile" || true
    [ -n "${digestfile2-}" ] && rm -f "$digestfile2" || true
    # Preserve the status
    exit "$1"
}

trap 'on_exit "$?"' EXIT

# -----------------------------------------------------------------------------
# Server Communication
# -----------------------------------------------------------------------------

# Create a temporary file for HTTP headers.
hdrfile=$(mktemp -t "$NAME.hdr.XXXXXX")

get_response_header() {
    awk -v k="$1" '
        BEGIN { lk = tolower(k) }
        tolower($0) ~ "^" lk "[[:space:]]*:" {
            sub(/^[^:]*:[[:space:]]*/, "")   # remove "Header-Name: "
            sub(/\r$/, "")                   # strip trailing CR if present
            print
        }
    ' "$hdrfile"
}

# -----------------------------------------------------------------------------

USER_AGENT_HTTP_HEADER="User-Agent: $NAME/$VERSION"

log "Connecting to server..."

[ -n "$OPT_VERBOSE" ] && verbose "Probing for server URL redirections..." || true

# Probe the server URL for possible redirections.
curl -fsSL -D "$hdrfile" --compressed -I -H "$USER_AGENT_HTTP_HEADER" "$OPT_SERVER_URL" >/dev/null

new_location="$(get_response_header Location | tail -n1)"
if [ -n "$new_location" ]; then
    OPT_SERVER_URL="$new_location"
    opt_normalize_server_url
    [ -n "$OPT_VERBOSE" ] && verbose "Server URL is redirected to $OPT_SERVER_URL location." || true
else
    [ -n "$OPT_VERBOSE" ] && verbose "No server URL redirections found." || true
fi

# -----------------------------------------------------------------------------
# Server Capabilities
# -----------------------------------------------------------------------------

[ -n "$OPT_VERBOSE" ] && verbose "Retrieving server capabilities..." || true

# Retrieve server capabilities.
curl -fsSL -D "$hdrfile" --compressed -I -H "$USER_AGENT_HTTP_HEADER" "$OPT_SERVER_URL/capabilities?apiKey=$OPT_API_KEY" >/dev/null

CAPS_ACCEPT_ENCODING="$(get_response_header 'Accept-Encoding')"
[ -n "$OPT_VERBOSE" ] && verbose "Encodings accepted by server: $CAPS_ACCEPT_ENCODING" || true

log "Server connection established."

# -----------------------------------------------------------------------------
# Compression
# -----------------------------------------------------------------------------

# Choose compression
if printf '%s\n' "$CAPS_ACCEPT_ENCODING" | grep -qiE '(^|,)[[:space:]]*zstd[[:space:]]*(,|$)' && command -v zstd >/dev/null 2>&1; then
    REQUEST_CONTENT_ENCODING=zstd
elif printf '%s\n' "$CAPS_ACCEPT_ENCODING" | grep -qiE '(^|,)[[:space:]]*gzip[[:space:]]*(,|$)'; then
    REQUEST_CONTENT_ENCODING=gzip
else
    REQUEST_CONTENT_ENCODING=
fi

[ -n "$OPT_VERBOSE" ] && verbose "Negotiated request encoding: $REQUEST_CONTENT_ENCODING" || true

compress_file() {
    if [ -z "${REQUEST_CONTENT_ENCODING-}" ]; then
        cat "$1"
    elif [ "$REQUEST_CONTENT_ENCODING" = "gzip" ]; then
        gzip -c -f "$1"
    elif [ "$REQUEST_CONTENT_ENCODING" = "zstd" ]; then
        zstd -c -f "$1"
    else
        echo "$NAME: internal error: unsupported REQUEST_CONTENT_ENCODING." >&2
        exit 1
    fi
}

# -----------------------------------------------------------------------------
# Server API
# -----------------------------------------------------------------------------

hex_to_bin() {
    if command -v xxd >/dev/null 2>&1; then
        xxd -r -p
    else
        awk '{ for (i=1; i<=length($0); i+=2) printf "%c", strtonum("0x" substr($0,i,2)) }'
    fi
}

sha256_b64() {
    sha256sum "$1" | awk '{print $1}' | hex_to_bin | base64
}

sha256_digest() {
    echo "sha-256=$(sha256_b64 "$1")"
}

call_file_api() {
    local file=$1
    local call

    case "$OPT_COMMAND" in
    sign)
        call=sign-file
        ;;
    echo)
        call=echo-file
        ;;
    *)
        echo "$NAME: internal error: unhandled API call command '$OPT_COMMAND'." >&2
        exit 1
        ;;
    esac

    # Extract a file extension from the input file name: "input_file.msi" -> "msi".
    # It may be used for selection of a file processing strategy on the server.
    local fileext
    fileext=$(get_file_extension "$file")

    compress_file "$file" |
        curl -sSL "$2" -D "$hdrfile" --compressed -X POST --data-binary @- \
            -H "X-File-Extension: $fileext" -H "Content-Encoding: $REQUEST_CONTENT_ENCODING" -H "Want-Repr-Digest: sha-256=1" -H "Repr-Digest: ${HTTP_REPR_DIGEST-}" \
            -H "$USER_AGENT_HTTP_HEADER" "$OPT_SERVER_URL/$call?apiKey=$OPT_API_KEY"
}

get_expected_repr_digest() {
    get_response_header "Repr-Digest"
}

get_expected_request_repr_digest() {
    get_response_header "X-Request-Repr-Digest"
}

# -----------------------------------------------------------------------------
# Ping
# -----------------------------------------------------------------------------

if [ "$OPT_COMMAND" = "ping" ]; then
    curl -sSL --fail-with-body -H "$USER_AGENT_HTTP_HEADER" "$OPT_SERVER_URL/ping?apiKey=$OPT_API_KEY"
    exit
fi

# -----------------------------------------------------------------------------
# Core Functionality
# -----------------------------------------------------------------------------

digest_verification_failed() {
    echo "$NAME: data integrity verification failed." >&2
    exit 1
}

process_file() {
    local FILE=$1

    if [ "$OPT_COMMAND" = "echo" ]; then
        log "Transferring file '$FILE'..."
    else
        log "Signing file '$FILE'..."
    fi

    if [ "$FILE" = "-" ]; then
        # Streaming mode

        [ -n "$OPT_VERBOSE" ] && verbose "Data exchange mode: streaming" || true

        [ "$OPT_COMMAND" = "echo" ] && [ -n "$OPT_VERBOSE" ] && verbose "ECHO mode is active." || true
        [ -n "$OPT_VERBOSE" ] && verbose "Streaming the data..." || true

        # Sign the data using the API in streaming mode, calculate in/out digests
        # progressively while doing it.
        tee >(sha256_digest - >"$digestfile1") | call_file_api - -f | tee >(sha256_digest - >"$digestfile2")

        # Verify request integrity.
        [ -n "$OPT_VERBOSE" ] && verbose "Validating server request digest..." || true
        EXPECTED_REQUEST_REPR_DIGEST=$(get_expected_request_repr_digest)
        if [ -n "$EXPECTED_REQUEST_REPR_DIGEST" ]; then
            ACTUAL_REQUEST_REPR_DIGEST=$(cat "$digestfile1")
            if [ "$EXPECTED_REQUEST_REPR_DIGEST" != "$ACTUAL_REQUEST_REPR_DIGEST" ]; then
                [ -n "$OPT_VERBOSE" ] && verbose "Request digest mismatch." || true
                digest_verification_failed
            fi
        fi

        # Verify response integrity.
        [ -n "$OPT_VERBOSE" ] && verbose "Validating server response digest..." || true
        EXPECTED_REPR_DIGEST=$(get_expected_repr_digest)
        ACTUAL_REPR_DIGEST=$(cat "$digestfile2")
        if [ "$EXPECTED_REPR_DIGEST" != "$ACTUAL_REPR_DIGEST" ]; then
            [ -n "$OPT_VERBOSE" ] && verbose "Response digest mismatch." || true
            digest_verification_failed
        fi

        [ -n "$OPT_VERBOSE" ] && verbose "The digests are validated." || true
    else
        # Batch mode

        [ -n "$OPT_VERBOSE" ] && verbose "Data exchange mode: batch" || true

        # Calculate content digest for integrity verification.
        [ -n "$OPT_VERBOSE" ] && verbose "Calculating content digest..." || true
        HTTP_REPR_DIGEST="$(sha256_digest "$FILE")"

        [ -n "$OPT_VERBOSE" ] && verbose "Calling the server API..." || true

        # Sign the input file and store result in the temporary file.
        status=0 && call_file_api "$FILE" --fail-with-body >"$tmpfile" || status=$?

        if [ "$status" -ne 0 ]; then
            # Write the error to stderr
            echo "Error message from the server:" >&2
            cat "$tmpfile" >&2
            exit "$status"
        fi

        EXPECTED_REPR_DIGEST=$(get_expected_repr_digest)

        [ -n "$OPT_VERBOSE" ] && verbose "Validating server response digest..." || true

        case $EXPECTED_REPR_DIGEST in
        "")
            # Digest is not specified. This means a broken HTTP response
            [ -n "$OPT_VERBOSE" ] && verbose "Digest not specified, assuming a broken response from the server." || true
            digest_verification_failed
            ;;
        sha-256=*)
            [ -n "$OPT_VERBOSE" ] && verbose "Using SHA-256 algorithm for digest validation." || true
            ACTUAL_REPR_DIGEST="$(sha256_digest "$tmpfile")"
            if [ "$EXPECTED_REPR_DIGEST" != "$ACTUAL_REPR_DIGEST" ]; then
                [ -n "$OPT_VERBOSE" ] && verbose "Response digest mismatch." || true
                digest_verification_failed
            fi
            ;;
        *)
            # Unsupported digest algorithm
            [ -n "$OPT_VERBOSE" ] && verbose "Unsupported digest algorithm." || true
            digest_verification_failed
            ;;
        esac

        [ -n "$OPT_VERBOSE" ] && verbose "Response digest validated." || true

        [ -n "$OPT_DRY" ] && [ -n "$OPT_VERBOSE" ] && verbose "DRY mode is active, not storing the result." || true

        if [ -z "$OPT_DRY" ] && [ "$OPT_COMMAND" = "sign" ]; then
            # Atomically replace the destination file.
            [ -n "$OPT_VERBOSE" ] && verbose "Atomically replacing the destination file..." || true
            mv -f "$tmpfile" "$FILE"
            [ -n "$OPT_VERBOSE" ] && verbose "The file has been successfully replaced." || true
        fi
    fi
}

# Create temporary files before entering any subshells, ensuring they can be
# tracked and cleaned up on exit by a trap
tmpfile=$(mktemp -t "$NAME.XXXXXX")
digestfile1="$tmpfile"
digestfile2=$(mktemp -t "$NAME.digest2.XXXXXX")

# Preserve the original stdin on FD 3
exec 3<&0

# Process files
echo "$OPT_FILES" | awk '!seen[$0]++' | while IFS= read -r file; do
    # Give process_file the real stdin, not the pipeline
    process_file "$file" <&3
done

# Close extra FD 3 when done
exec 3<&-

if [ "$OPT_COMMAND" = "echo" ]; then
    log "Files have been transferred successfully."
    log "Echo check passed."
else
    log "Files have been signed successfully."
fi

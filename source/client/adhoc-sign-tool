#!/usr/bin/env bash

set -euo pipefail

# -----------------------------------------------------------------------------

NAME=adhoc-sign-tool
VERSION=0.0.0

help() {
    echo "$NAME  Version $VERSION
Copyright Â© Gapotchenko and Contributors

Processes the specified file(s) using the 'adhoc-file-signer' service.

Usage:
  adhoc-sign-tool sign --server <server-url> -k <api-key> <file...>
                       [--dry] [--verbose]
  adhoc-sign-tool echo --server <server-url> -k <api-key> <file...>
                       [--verbose]
  adhoc-sign-tool ping --server <server-url> -k <api-key> [--verbose]

Commands:
  sign  Sign the specified file(s) using the server.
  echo  Send the specified file(s) to the server and recieve them back
        unmodified. Useful for testing connectivity and data transfer.
  ping  Ping the server using its API. Useful for testing connectivity and
        verifying authorization.

Options:
  --server      The server URL. If omitted, the value of
                GP_ADHOC_FILE_SIGNER_SERVER environment variable is used.
  -k --api-key  The API authorization key. If omitted, the value of
                GP_ADHOC_FILE_SIGNER_API_KEY environment variable is used.
  --verbose     Enable verbose output.
  --dry         Perform a dry run without applying any modifications."
}

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

if [ $# -eq 0 ]; then
    echo "$NAME: missing program arguments
Try '$NAME --help' for more information." >&2
    exit 2
fi

COMMAND=
SERVER_URL="${GP_ADHOC_FILE_SIGNER_SERVER-}"
API_KEY="${GP_ADHOC_FILE_SIGNER_API_KEY-}"
FILES=""
DRY=""
VERBOSE=""

HAS_STDIN_FILE=0

add_file() {
    if [ "$1" = "-" ]; then
        HAS_STDIN_FILE=1
    fi

    if [ -z "$FILES" ]; then
        FILES=$1
    else
        FILES="$FILES
$1"
    fi
}

# Parse options
while [ $# -gt 0 ]; do
    case "$1" in
    --help)
        help
        exit
        ;;
    --server)
        SERVER_URL="$2"
        shift 2
        ;;
    -k | --api-key)
        API_KEY="$2"
        shift 2
        ;;
    --dry)
        DRY=1
        shift
        ;;
    --verbose)
        VERBOSE=1
        shift
        ;;
    --)
        shift
        break
        ;;
    -)
        add_file "$1"
        shift
        ;;
    -*)
        echo "$NAME: unknown option: $1" >&2
        exit 2
        ;;
    *)
        # Positional arguments
        if [ -z "$COMMAND" ]; then
            case "$1" in
            echo | ping | sign)
                COMMAND=$1
                ;;
            *)
                echo "$NAME: unknown command: $1" >&2
                exit 2
                ;;
            esac
        else
            add_file "$1"
        fi
        shift
        ;;
    esac
done

# Validate options

missing_option_error() {
    echo "$NAME: $1 is not specified." >&2
    exit 2
}

if [ -z "$COMMAND" ]; then
    missing_option_error 'command'
fi
if [ -z "$SERVER_URL" ]; then
    missing_option_error 'server URL'
fi
if [ -z "$API_KEY" ]; then
    missing_option_error 'API key'
fi

if [ -n "$DRY" ]; then
    case "$COMMAND" in
    sign) ;;
    *)
        echo "$NAME: '--dry' option can only be used with 'sign' command." >&2
        exit 2
        ;;
    esac
fi

# Complete parsing the rest of positional arguments
while [ $# -gt 0 ]; do
    add_file "$1"
    shift
done

# Validate positional arguments
case "$COMMAND" in
echo | sign)
    if [ -z "$FILES" ]; then
        echo "$NAME: missing file argument." >&2
        exit 2
    fi
    ;;
*)
    if [ -n "$FILES" ]; then
        echo "$NAME: files can only be specified for 'echo' and 'sign' commands." >&2
        exit 2
    fi
    ;;
esac

# Options normalization

normalize_server_url() {
    SERVER_URL=${SERVER_URL%/}
}

normalize_server_url

# -----------------------------------------------------------------------------
# Auxilary Functions
# -----------------------------------------------------------------------------

log() {
    if [ $HAS_STDIN_FILE -eq 1 ]; then
        echo "$1" >&2
    else
        echo "$1"
    fi
}

verbose() {
    echo "LOG: $1" >&2
}

on_exit() {
    if [ "$1" -ne 0 ]; then
        echo "$NAME: failed with status $1." >&2
    fi
    # Cleanup
    [ -n "${hdrfile-}" ] && rm -f "$hdrfile" || true
    [ -n "${tmpfile-}" ] && rm -f "$tmpfile" || true
    [ -n "${digestfile2-}" ] && rm -f "$digestfile2" || true
    # Preserve the exit status.
    exit "$1"
}

trap 'on_exit "$?"' EXIT

# -----------------------------------------------------------------------------
# Server Communication
# -----------------------------------------------------------------------------

# Create a temporary file for HTTP headers.
hdrfile=$(mktemp -t "$NAME.hdr.XXXXXX")

get_response_header() {
    sed -n "s/^$1:[[:space:]]*//Ip" "$hdrfile"
}

# -----------------------------------------------------------------------------

USER_AGENT_HTTP_HEADER="User-Agent: $NAME/$VERSION"

log "Connecting to server..."

[ -n "$VERBOSE" ] && verbose "Probing for server URL redirections..." || true

# Probe the server URL for possible redirections.
curl -fsSL -D "$hdrfile" --compressed -I -H "$USER_AGENT_HTTP_HEADER" "$SERVER_URL" >/dev/null

new_location="$(get_response_header Location | tail -n1)"
if [ -n "$new_location" ]; then
    SERVER_URL="$new_location"
    normalize_server_url
    [ -n "$VERBOSE" ] && verbose "Server URL is redirected to $SERVER_URL location." || true
else
    [ -n "$VERBOSE" ] && verbose "No server URL redirections found." || true
fi

# -----------------------------------------------------------------------------
# Server Capabilities
# -----------------------------------------------------------------------------

[ -n "$VERBOSE" ] && verbose "Retrieving server capabilities..." || true

# Retrieve server capabilities.
curl -fsSL -D "$hdrfile" --compressed -I -H "$USER_AGENT_HTTP_HEADER" "$SERVER_URL/capabilities?apiKey=$API_KEY" >/dev/null

CAPS_ACCEPT_ENCODING="$(get_response_header 'Accept-Encoding')"
[ -n "$VERBOSE" ] && verbose "Encodings accepted by server: $CAPS_ACCEPT_ENCODING" || true

log "Server connection established."

# -----------------------------------------------------------------------------
# Compression
# -----------------------------------------------------------------------------

# Choose compression
if printf '%s\n' "$CAPS_ACCEPT_ENCODING" | grep -qiE '(^|,)[[:space:]]*zstd[[:space:]]*(,|$)' && command -v zstd >/dev/null 2>&1; then
    REQUEST_CONTENT_ENCODING=zstd
elif printf '%s\n' "$CAPS_ACCEPT_ENCODING" | grep -qiE '(^|,)[[:space:]]*gzip[[:space:]]*(,|$)'; then
    REQUEST_CONTENT_ENCODING=gzip
else
    REQUEST_CONTENT_ENCODING=
fi

[ -n "$VERBOSE" ] && verbose "Negotiated request encoding: $REQUEST_CONTENT_ENCODING" || true

compress_file() {
    if [ -z "${REQUEST_CONTENT_ENCODING-}" ]; then
        cat "$1"
    elif [ "$REQUEST_CONTENT_ENCODING" = "gzip" ]; then
        gzip -c -f "$1"
    elif [ "$REQUEST_CONTENT_ENCODING" = "zstd" ]; then
        zstd -c -f "$1"
    else
        echo "$NAME: internal error: unsupported REQUEST_CONTENT_ENCODING." >&2
        exit 1
    fi
}

# -----------------------------------------------------------------------------
# Server API
# -----------------------------------------------------------------------------

hex_to_bin() {
    if command -v xxd >/dev/null 2>&1; then
        xxd -r -p
    else
        awk '{ for (i=1; i<=length($0); i+=2) printf "%c", strtonum("0x" substr($0,i,2)) }'
    fi
}

sha256_b64() {
    sha256sum "$1" | awk '{print $1}' | hex_to_bin | base64
}

sha256_digest() {
    echo "sha-256=$(sha256_b64 "$1")"
}

call_file_api() {
    local file=$1
    local call

    case "$COMMAND" in
    sign)
        call=sign-file
        ;;
    echo)
        call=echo-file
        ;;
    *)
        echo "$NAME: internal error: unhandled API call command '$COMMAND'." >&2
        exit 1
        ;;
    esac

    # Extract an extension from the file name: input_file.msi -> .msi
    # It may be used for selection of a file processing strategy on server.
    ext=$(expr "$file" : '.*\.\([^.]*\)$')

    compress_file "$file" |
        curl -sSL "$2" -D "$hdrfile" --compressed -X POST --data-binary @- \
            -H "X-File-Extension: $ext" -H "Content-Encoding: $REQUEST_CONTENT_ENCODING" -H "Want-Content-Digest: sha-256=1" -H "Content-Digest: ${HTTP_CONTENT_DIGEST-}" \
            -H "$USER_AGENT_HTTP_HEADER" "$SERVER_URL/$call?apiKey=$API_KEY"
}

get_expected_content_digest() {
    get_response_header "Content-Digest"
}

get_expected_request_content_digest() {
    get_response_header "X-Request-Content-Digest"
}

# -----------------------------------------------------------------------------
# Ping
# -----------------------------------------------------------------------------

if [ "$COMMAND" = "ping" ]; then
    curl -sSL --fail-with-body -H "$USER_AGENT_HTTP_HEADER" "$SERVER_URL/ping?apiKey=$API_KEY"
    exit
fi

# -----------------------------------------------------------------------------
# Core Functionality
# -----------------------------------------------------------------------------

digest_verification_failed() {
    echo "$NAME: data integrity verification failed." >&2
    exit 1
}

process_file() {
    local FILE=$1

    if [ "$COMMAND" = "echo" ]; then
        log "Transferring file '$FILE'..."
    else
        log "Signing file '$FILE'..."
    fi

    if [ "$FILE" = "-" ]; then
        # Streaming mode

        [ -n "$VERBOSE" ] && verbose "Data exchange mode: streaming" || true

        [ "$COMMAND" = "echo" ] && [ -n "$VERBOSE" ] && verbose "ECHO mode is active." || true
        [ -n "$VERBOSE" ] && verbose "Streaming the data..." || true

        # Sign the data using the API in streaming mode, calculate in/out digests
        # progressively while doing it.
        tee >(sha256_digest - >"$digestfile1") | call_file_api - -f | tee >(sha256_digest - >"$digestfile2")

        # Verify request integrity.
        [ -n "$VERBOSE" ] && verbose "Validating server request digest..." || true
        EXPECTED_REQUEST_CONTENT_DIGEST=$(get_expected_request_content_digest)
        if [ -n "$EXPECTED_REQUEST_CONTENT_DIGEST" ]; then
            ACTUAL_REQUEST_CONTENT_DIGEST=$(cat "$digestfile1")
            if [ "$EXPECTED_REQUEST_CONTENT_DIGEST" != "$ACTUAL_REQUEST_CONTENT_DIGEST" ]; then
                [ -n "$VERBOSE" ] && verbose "Request digest mismatch." || true
                digest_verification_failed
            fi
        fi

        # Verify response integrity.
        [ -n "$VERBOSE" ] && verbose "Validating server response digest..." || true
        EXPECTED_CONTENT_DIGEST=$(get_expected_content_digest)
        ACTUAL_CONTENT_DIGEST=$(cat "$digestfile2")
        if [ "$EXPECTED_CONTENT_DIGEST" != "$ACTUAL_CONTENT_DIGEST" ]; then
            [ -n "$VERBOSE" ] && verbose "Response digest mismatch." || true
            digest_verification_failed
        fi

        [ -n "$VERBOSE" ] && verbose "The digests are validated." || true
    else
        # Batch mode

        [ -n "$VERBOSE" ] && verbose "Data exchange mode: batch" || true

        # Calculate content digest for integrity verification.
        [ -n "$VERBOSE" ] && verbose "Calculating content digest..." || true
        HTTP_CONTENT_DIGEST="$(sha256_digest "$FILE")"

        [ -n "$VERBOSE" ] && verbose "Calling the server API..." || true

        # Sign the input file and store result in the temporary file.
        status=0 && call_file_api "$FILE" --fail-with-body >"$tmpfile" || status=$?

        if [ "$status" -ne 0 ]; then
            # Write the error to stderr
            echo "Error message from the server:" >&2
            cat "$tmpfile" >&2
            exit "$status"
        fi

        EXPECTED_CONTENT_DIGEST=$(get_expected_content_digest)

        [ -n "$VERBOSE" ] && verbose "Validating server response digest..." || true

        case $EXPECTED_CONTENT_DIGEST in
        "")
            # Digest is not specified. This means a broken HTTP response
            [ -n "$VERBOSE" ] && verbose "Digest not specified, assuming a broken response from the server." || true
            digest_verification_failed
            ;;
        sha-256=*)
            [ -n "$VERBOSE" ] && verbose "Using SHA-256 algorithm for digest validation." || true
            ACTUAL_CONTENT_DIGEST="$(sha256_digest "$tmpfile")"
            if [ "$EXPECTED_CONTENT_DIGEST" != "$ACTUAL_CONTENT_DIGEST" ]; then
                [ -n "$VERBOSE" ] && verbose "Response digest mismatch." || true
                digest_verification_failed
            fi
            ;;
        *)
            # Unsupported digest algorithm
            [ -n "$VERBOSE" ] && verbose "Unsupported digest algorithm." || true
            digest_verification_failed
            ;;
        esac

        [ -n "$VERBOSE" ] && verbose "Response digest validated." || true

        [ -n "$DRY" ] && [ -n "$VERBOSE" ] && verbose "DRY mode is active, not storing the result." || true

        if [ -z "$DRY" ] && [ "$COMMAND" = "sign" ]; then
            # Atomically replace the destination file.
            [ -n "$VERBOSE" ] && verbose "Atomically replacing the destination file..." || true
            mv -f "$tmpfile" "$FILE"
            [ -n "$VERBOSE" ] && verbose "The file has been successfully replaced." || true
        fi
    fi
}

# Create temporary files before entering any subshells, ensuring they can be
# tracked and cleaned up on exit by a trap
tmpfile=$(mktemp -t "$NAME.XXXXXX")
digestfile1="$tmpfile"
digestfile2=$(mktemp -t "$NAME.digest2.XXXXXX")

# Preserve the original stdin on FD 3
exec 3<&0

echo "$FILES" | awk '!seen[$0]++' | while IFS= read -r file; do
    # Give process_file the real stdin, not the pipeline
    process_file "$file" <&3
done

# Close extra FD 3 when done
exec 3<&-

if [ "$COMMAND" = "echo" ]; then
    log "Files have been transferred successfully."
    log "Echo check passed."
else
    log "Files have been signed successfully."
fi
